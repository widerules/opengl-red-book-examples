Пример 1 данного приложения соответствует примеру 1-1 из красной книги OpenGL:

 === 1.2 Немного OpenGL кода ===
 Поскольку при помощи библиотеки OpenGL можно делать так много вещей,   программа, использующая ее, может быть весьма сложна. Однако базовая структура полезной программы может быть достаточно простой: ее задачами являются инициализация нескольких переменных или переключателей, контролирующих, как OpenGL осуществляет визуализацию изображения и, далее, указание объектов для отображения. 
 До того, как будет приведен небольшой пример, определимся с некоторыми терминами. Визуализация (rendering) – это процесс, с помощью которого компьютер создает изображения из моделей. Эти модели или объекты строятся из геометрических примитивов – точек, линий и полигонов, которые в свою очередь, определяются своими вершинами (vertices). 
 Результирующее изображение состоит из пикселей отображенных на экране.      Пиксель – это самый маленький видимый элемент, который монитор может поместить на свой экран. 
 Информация о пикселях (например, какого цвета они должны быть)  организована в памяти в виде битовых поверхностей (bitplanes). Битовая плоскость – это область памяти, содержащая один бит информации на каждый пиксель экрана. Этот бит может определять, например, насколько красным должен быть конкретный пиксель. Сами битовые плоскости организованы в буфер кадра, который содержит всю информацию необходимую монитору, чтобы контролировать цвет и интенсивность всех пикселей на экране. 
 Теперь посмотрим, на что может быть похожа OpenGL – программа. Пример 1-1 отображает белый квадрат на черном фоне, показанный на рисунке 1. 
 Рисунок 1.1. Белый квадрат на черном фоне 
 
 Пример 1-1. Фрагмент OpenGL – кода 
 {{{
 #include <все_что_необходимо.h> 
 main()
 {
 ИнициализироватьОкно(); 
 glClearColor(0.0,0.0,0.0);
 glClear(GL_COLOR_BUFFER_BIT);
 glColor3f(1.0,1.0,1.0);
 glOrtho(0.0,1.0,0.0,1.0,-1.0,1.0);
 glBegin(GL_POLYGON);
 glVertex3f(0.25,0.25,0.0);
 glVertex3f(0.75,0.25,0.0);
 glVertex3f(0.75,0.75,0.0);
 glVertex3f(0.25,0.75,0.0);
 glEnd();
 glFlush(); 
 ОбновитьОкно();
 } 
 }}}
 Первая строка функции main() инициализирует окно на экране.  ИнициализироватьОкно() обозначает то место в тексте, куда надо поместить  функции создания окна, зависимые от оконной системы, в которой вы  работаете и не являющиеся командами OpenGL. Две следующих строки  являются командами OpenGL, окрашивающими окно в черный цвет:   glClearColor() задает цвет, в который окно будет окрашиваться при его  очистке, glClear() как раз и очищает окно. После того, как «очищающий  цвет» задан, окно всегда будет окрашиваться именно в него при вызовах  glClear(). Этот цвет может быть изменен повторным вызовом  glClearColor(). Похожим же образом glColor3f() задает цвет, который  будет использоваться для рисования объектов – в данном случае белый.  Начиная с этого момента, все объекты будут рисоваться белыми до тех пор,   пока не последует замена этого цвета на другой при помощи одной из  команд OpenGL. 
 Следующая OpenGL – команда, использованная в программе, glOrtho(), определяет координатную систему, на которую полагается OpenGL при  отрисовке финального изображения и проецировании изображения на экран.  Вызовы, заключенные в команды glBegin() и glEnd(), определяют объект,  который следует нарисовать – в данном случае полигон с 4 вершинами.  «Углы» полигона определяются командами glVertex3f(). Как можно  догадаться по значениям аргументов, которые являются координатами (x, y,  z), полигон представляет собой квадрат в плоскости z=0. 
 Наконец, вызов glFlush() позволяет быть уверенным в том, что команды  OpenGL действительно выполнились, а не были сохранены в буфере в  ожидании дальнейших команд. ОбновитьОкно() – это опять-таки метка для функций, зависящих от оконной системы. 
 На самом деле этот фрагмент кода не слишком хорошо структурирован. Могут возникнуть вопросы: «Что если мы попытаемся изменить размер окна или переместить его?» «Необходимо ли устанавливать координатную систему каждый раз при отрисовке квадрата?» Позже ИнициализироватьОкно() и ОбновитьОкно() будут заменены на реально работающие вызовы, которые, однако, требуют реструктуризации кода, что сделает его более эффективным. 